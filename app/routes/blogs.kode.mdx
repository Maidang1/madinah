---
title: Kode 框架完整处理流程解析
author: Madinah
tags:
  - AI
  - Agent
time: 2025-10-29 00:00:00
---





## 整体流程

```plainText

基于对源码的分析，我来详细解释 Kode 框架从用户输入到大模型返回 的完整处理流程：

  🔄 完整处理流程

  第一阶段：输入捕获与初始化

  1. CLI 入口 (src/entrypoints/cli.tsx)
  用户执行命令 → cli.tsx 解析参数 → 设置工作目录 → 初始化配置 → 渲染 REPL 界面

  2. REPL 界面 (src/screens/REPL.tsx)
  - 使用 Ink 框架 (React for CLI) 渲染交互界面
  - 捕获用户输入 (PromptInput 组件)
  - 管理消息历史和状态

  第二阶段：输入预处理

  3. 输入分类 (src/utils/messages.tsx - processUserInput)
  用户输入 → 判断输入类型：
  ├─ 命令输入 (以 / 开头) → `/help`, `/model`, `/config` 等
  ├─ Bash 输入 → 直接执行 shell 命令
  ├─ Koding 输入 → 特殊模式处理
  └─ 普通 Prompt → 进入 AI 查询流程

  4. 消息规范化
  - 创建 UserMessage 对象
  - 规范化消息格式 (ContentBlock 数组)
  - 添加到消息历史

  第三阶段：AI 查询核心流程

  5. Query 主函数 (src/query.ts - query)
  这是整个系统的核心异步生成器，处理流程：

  query(messages, systemPrompt, context, canUseTool, toolUseContext)
  ├─ 1. 自动压缩检查 (checkAutoCompact)
  ├─ 2. 系统提示词格式化 (formatSystemPromptWithContext)
  ├─ 3. 注入系统提醒 (reminders)
  ├─ 4. 调用 LLM (queryLLM)
  ├─ 5. 二进制反馈检查 (可选)
  ├─ 6. 处理模型响应
  │   ├─ 无工具调用 → 返回文本响应
  │   └─ 有工具调用 → 进入工具执行阶段
  └─ 7. 递归查询 (如果有工具结果)

  第四阶段：模型调用

  6. LLM 调用 (src/services/claude.ts - queryLLM)
  queryLLM(
    normalizeMessagesForAPI(messages),  // 规范化消息格式
    fullSystemPrompt,                   // 系统提示词
    maxThinkingTokens,                  // 思考token数
    tools,                             // 可用工具列表
    abortController.signal,            // 取消信号
    options                            // 选项配置
  )
  ├─ 获取模型配置 (ModelManager)
  ├─ 构建请求参数
  ├─ 选择服务提供商:
  │   ├─ Anthropic API
  │   ├─ OpenAI API
  │   ├─ Bedrock API
  │   └─ Vertex API
  └─ 发送 HTTP 请求并接收响应

  7. 多模型支持 (src/utils/model.ts)
  ModelManager:
  ├─ 模型配置管理 (API keys, endpoints, capabilities)
  ├─ 模型指针系统:
  │   ├─ main → 主对话模型
  │   ├─ task → 子任务模型
  │   ├─ reasoning → 推理模型
  │   └─ quick → 快速响应模型
  ├─ 动态切换 (Tab 键, /model 命令)
  └─ 成本跟踪

  第五阶段：工具执行系统

  8. 工具发现与验证 (src/query.ts - runToolUse)
  runToolUse(toolUse, siblingToolUseIDs, assistantMessage, ...)
  ├─ 查找工具 (toolUseContext.options.tools)
  ├─ 输入验证 (Zod schema)
  ├─ 业务逻辑验证 (tool.validateInput)
  ├─ 权限检查 (canUseTool)
  └─ 执行工具 (tool.call)

  9. 并发控制
  if (所有工具都是只读的) {
      → 并行执行 (runToolsConcurrently, 最多10个)
  } else {
      → 串行执行 (runToolsSerially)
  }

  10. 权限系统 (src/permissions.ts)
  Safe Mode:
  ├─ YOLO 模式 (默认) → 跳过权限检查
  ├─ Safe 模式 (--safe) → 启用权限检查
  │   ├─ 文件读取权限
  │   ├─ 文件写入权限
  │   ├─ 命令执行权限
  │   └─ 网络访问权限
  └─ 用户交互式批准

  第六阶段：响应回传与UI更新

  11. 工具结果处理
  工具执行结果 → UserMessage → 规范化格式 → 返回给模型

  12. 递归查询
  原始消息 + Assistant响应 + Tool结果 → 重新调用 query()
  └─ 继续直到无需更多工具调用

  13. UI 更新
  - 实时显示工具执行进度 (ProgressMessage)
  - 显示最终响应 (MessageResponse 组件)
  - 更新消息历史
  - 更新成本统计

  🎯 关键特性

  智能上下文管理

  - MessageContextManager 自动管理上下文窗口
  - 智能压缩 (Auto-compaction) 避免超限
  - 持久化内存工具 (MemoryReadTool, MemoryWriteTool)

  @ 提及系统

  用户输入: "@ask-claude-sonnet-4 分析这段代码"
            "@run-agent-test-writer 写测试"
            "@src/components/Button.tsx"

  解析流程:
  ├─ 检测 @ 符号
  ├─ 智能补全 (模糊匹配, 缩写展开)
  ├─ 特殊处理:
  │   ├─ @ask-model → 专家咨询模式
  │   ├─ @run-agent → 智能体委托
  │   └─ @file → 文件引用
  └─ 转换为标准消息格式

  调试与监控

  - 详细的调试日志 (debugLogger.ts)
  - 阶段标记 (markPhase)
  - 成本跟踪 (costTracker.ts)
  - 性能监控

  🔌 数据流图

  用户输入
      ↓
  [REPL UI] (Ink/React)
      ↓
  [输入分类] (messages.tsx)
      ↓
  [消息规范化] (UserMessage)
      ↓
  [Query Generator] (query.ts)
      ↓
  [系统提示词] (formatSystemPromptWithContext)
      ↓
  [LLM 调用] (claude.ts)
      ↓
  [模型响应] (Anthropic/OpenAI API)
      ↓
  [工具调用?] ─YES→ [工具执行] (runToolUse)
      ↓                      ↓
     YES                  [权限检查]
      ↓                      ↓
  [递归查询]             [执行工具]
      ↓                      ↓
     ...                  [返回结果]
      ↓                      ↓
     NO ────────────────→ [规范化结果]
      ↓                      ↓
  [UI 渲染] ←─────────── [继续查询]
      ↓
  [最终响应]

  这个流程展示了 Kode 框架如何通过多个层次的处理，从简单的用户输入转化为复杂的 AI 驱动的工作流，支持多模型协作、工具执行和智能上下文管理