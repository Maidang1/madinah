{"/blogs/farmfe-plugins-ci":"The blog introduces farm plugins CI for JavaScript and Rust plugins. For Rust plugins, it builds for multiple platforms and deploys to npm registry. For JavaScript plugins, similar steps are followed. Both use pnpm --filter '{xx}[HEAD~1]' to build only changed plugins and contains to determine if CI should run. The summary emphasizes these two points for reducing build time and controlling CI execution.","/rusts/start":"**Blog Summary**\n\nThe blog post is about getting started with the Rust programming language. The author, Madinah, provides a simple example of a \"hello, world\" program in Rust.\n\nIn this example, the `main` function is defined, which contains the `println!` macro that prints \"Hello, world!\" to the console.\n\nThis post is likely intended for beginners who want to learn how to write their first Rust program. The simplicity of the code makes it accessible to those new to programming languages.\n\nThe author's goal appears to be introducing readers to the basics of Rust and encouraging them to try out the language themselves. Overall, this post provides a concise introduction to getting started with Rust.","/rusts/async":"This is a Rust code that demonstrates the use of Tokio, a Rust library for building concurrent and asynchronous applications. The code showcases several aspects of Tokio, including:\n\n1.  **Semaphore**: A semaphore is used to limit the number of tasks that can run concurrently. In this example, two semaphores are created: `semaphore` with one permit, which allows only one task to run at a time, and `semaphore_wait` with zero permits, which blocks until the first semaphore's permit becomes available.\n2.  **Task creation**: Two tasks (`t1` and `t2`) are spawned using Tokio's `task::Builder`. Each task runs a loop that prints numbers from 0 to `cnt-1`, waiting for the corresponding number of seconds between each print.\n3.  **Joining tasks**: The two tasks are joined together using `tokio::try_join!`, which waits for both tasks to complete before returning.\n\nThe code also demonstrates the use of the `await-tree` crate, which provides a way to instrument and measure the execution time of asynchronous functions. In this example, the `bar` function is instrumented with an await tree, which allows us to track the execution time of each task in the call stack.\n\nFinally, the code showcases the `openharmony` framework, which provides a high-level API for building concurrent and asynchronous applications. The code demonstrates how to create a registry, register tasks with it, and use the registry to instrument and measure task execution times.\n\nThese examples demonstrate the power and flexibility of Tokio and the `await-tree` crate, making it easier to write efficient and performant Rust applications that take full advantage of concurrency and asynchronous programming."}